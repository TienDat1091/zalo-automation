<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Qu·∫£n l√Ω L·ªãch G·ª≠i - Zalo Bot</title>
    <link rel="stylesheet" href="/assets/style_bank_manager.css">
    <style>
        /* Additional styles for Scheduled Manager */
        .status-badge.pending {
            background: #fff3cd;
            color: #856404;
        }

        .status-badge.completed {
            background: #d4edda;
            color: #155724;
        }

        .status-badge.failed {
            background: #f8d7da;
            color: #721c24;
        }

        .type-badge {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: 600;
        }

        .type-badge.text {
            background: #e2e3e5;
            color: #383d41;
        }

        .type-badge.flow {
            background: #cce5ff;
            color: #004085;
        }

        .type-badge.forward {
            background: #d1e7dd;
            color: #0f5132;
        }
    </style>
</head>

<body>
    <div class="header">
        <div class="header-content">
            <h1>üìÖ Qu·∫£n l√Ω L·ªãch G·ª≠i</h1>
            <div class="header-actions">
                <button class="btn btn-primary" onclick="openCreateTask()">+ Th√™m l·ªãch m·ªõi</button>
            </div>
        </div>
    </div>

    <!-- FullCalendar CDN -->
    <script src='https://cdn.jsdelivr.net/npm/fullcalendar@6.1.10/index.global.min.js'></script>
    <style>
        .view-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .view-btn {
            padding: 8px 16px;
            border: 1px solid #ddd;
            background: #fff;
            cursor: pointer;
            border-radius: 4px;
        }

        .view-btn.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        #calendar {
            max-width: 100%;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
    </style>

    <div class="main-content">
        <div class="card">
            <div class="card-header">
                <h2>üìã Danh s√°ch l·ªãch g·ª≠i</h2>
                <div class="view-controls">
                    <button class="view-btn active" onclick="switchView('list')">üìÑ Danh s√°ch</button>
                    <button class="view-btn" onclick="switchView('calendar')">ÔøΩ L·ªãch</button>
                </div>
            </div>

            <div class="card-body" id="listView">
                <div class="table-responsive">
                    <table>
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Ng∆∞·ªùi nh·∫≠n</th>
                                <th>Lo·∫°i</th>
                                <th>N·ªôi dung / Flow</th>
                                <th>Th·ªùi gian g·ª≠i</th>
                                <th>Tr·∫°ng th√°i</th>
                                <th>Ng√†y t·∫°o</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody id="tasksTable">
                            <tr>
                                <td colspan="8">
                                    <div class="empty-state">
                                        <div class="icon">üìÖ</div>
                                        <h3>ƒêang t·∫£i d·ªØ li·ªáu...</h3>
                                    </div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="card-body" id="calendarView" style="display:none;">
                <div id="calendar"></div>
            </div>
        </div>
    </div>

    <!-- Modal: Create/Edit Task -->
    <div class="modal-overlay" id="taskModal">
        <div class="modal-content" style="display:flex; flex-direction:column; max-height:85vh; overflow:hidden;">
            <div class="modal-header" style="flex-shrink:0;">
                <h3 id="taskModalTitle">T·∫°o l·ªãch g·ª≠i m·ªõi</h3>
                <button class="modal-close" onclick="closeTaskModal()">√ó</button>
            </div>
            <div class="modal-body" style="overflow-y:auto; flex:1;">
                <input type="hidden" id="editingTaskId">
                <div class="form-group" id="singleTargetGroup">
                    <label>Ng∆∞·ªùi nh·∫≠n (Target ID) <span class="required">*</span></label>
                    <select class="form-control" id="taskTargetSelect" onchange="onSingleTargetChange()">
                        <option value="">-- Ch·ªçn ng∆∞·ªùi nh·∫≠n --</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>Lo·∫°i n·ªôi dung</label>
                    <select class="form-control" id="taskType" onchange="toggleTaskType()">
                        <option value="text">VƒÉn b·∫£n (Text)</option>
                        <option value="flow">K·ªãch b·∫£n (Flow)</option>
                        <option value="forward">Chuy·ªÉn ti·∫øp (Bulk Forward)</option>
                    </select>
                </div>

                <div class="form-group" id="groupContent">
                    <label>N·ªôi dung tin nh·∫Øn <span class="required">*</span></label>
                    <textarea class="form-control" id="taskContent" rows="3"
                        placeholder="Nh·∫≠p n·ªôi dung tin nh·∫Øn..."></textarea>

                    <div id="targetSelectionArea"
                        style="display:none; margin-top:15px; border-top:1px dashed #eee; padding-top:10px;">
                        <label>Ch·ªçn ng∆∞·ªùi nh·∫≠n <span class="required">*</span></label>

                        <div class="multi-select-controls"
                            style="display:flex; justify-content:space-between; margin-bottom:8px;">
                            <button type="button" class="btn btn-outline btn-sm" onclick="selectAllTargets()">‚òëÔ∏è Ch·ªçn
                                t·∫•t c·∫£</button>
                            <button type="button" class="btn btn-outline btn-sm" onclick="deselectAllTargets()">‚¨ú B·ªè
                                ch·ªçn</button>
                            <span id="selectedCount" style="font-size:12px; color:#666; align-self:center;">ƒê√£ ch·ªçn:
                                0</span>
                        </div>

                        <div id="multiSelectContainer"
                            style="max-height: 200px; overflow-y: auto; border: 1px solid #e2e8f0; border-radius: 8px; padding: 10px; background: #f8fafc;">
                            <div class="spinner"></div> ƒêang t·∫£i danh s√°ch...
                        </div>

                        <!-- Hidden input to store final result -->
                        <input type="hidden" id="taskTargetId">
                    </div>
                </div>


                <div id="flowInputGroup" style="display:none;">
                    <label style="display:block; margin-bottom:5px; font-weight:500;">Ch·ªçn K·ªãch b·∫£n (Flow)</label>
                    <select id="taskFlowSelect"
                        style="width:100%; padding:8px; border:1px solid #ddd; border-radius:4px;">
                        <option value="">-- ƒêang t·∫£i k·ªãch b·∫£n... --</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>Th·ªùi gian g·ª≠i <span class="required">*</span></label>
                    <input type="datetime-local" class="form-control" id="taskTime">
                </div>
            </div>
            <div class="modal-footer" style="flex-shrink:0;">
                <button class="btn btn-outline" onclick="closeTaskModal()">H·ªßy</button>
                <button class="btn btn-primary" onclick="saveTask()">üíæ L∆∞u l·ªãch</button>
            </div>
        </div>
    </div>

    <script>
        let ws = null;
        let tasks = [];
        let calendar = null;

        document.addEventListener('DOMContentLoaded', () => {
            connectWebSocket();
            const now = new Date();
            now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
            document.getElementById('taskTime').min = now.toISOString().slice(0, 16);
        });

        function connectWebSocket() {
            ws = new WebSocket((location.protocol === 'https:' ? 'wss:' : 'ws:') + '//' + location.host);
            ws.onopen = () => {
                console.log('‚úÖ Connected');
                ws.send(JSON.stringify({ type: 'get_scheduled_tasks' }));
                ws.send(JSON.stringify({ type: 'get_friends' }));
                ws.send(JSON.stringify({ type: 'get_groups' }));
                ws.send(JSON.stringify({ type: 'get_all_flows' }));
            };
            ws.onclose = () => setTimeout(connectWebSocket, 3000);
            ws.onmessage = (e) => {
                try { handleMessage(JSON.parse(e.data)); } catch (err) { console.error(err); }
            };
        }

        function handleMessage(data) {
            console.log('üì©', data.type, data);
            switch (data.type) {
                case 'scheduled_tasks_list':
                case 'scheduled_tasks_update':
                    tasks = data.tasks || [];
                    renderTasks();
                    if (calendar) updateCalendarEvents();
                    break;
                case 'scheduled_task_created':
                    if (data.success) {
                        closeTaskModal();
                        showToast('‚úÖ ƒê√£ t·∫°o l·ªãch g·ª≠i!', 'success');
                    }
                    break;
                case 'scheduled_task_updated': // Handled via update/list broadcast usually but good to know
                    if (data.success) {
                        closeTaskModal();
                        showToast('‚úÖ ƒê√£ c·∫≠p nh·∫≠t l·ªãch!', 'success');
                    }
                    break;
                case 'scheduled_task_deleted':
                    showToast('‚úÖ ƒê√£ x√≥a l·ªãch!', 'success');
                    break;
                case 'scheduled_task_error':
                    showToast('‚ùå ' + data.message, 'error');
                    break;
                case 'friends_list':
                    updateTargetSelect(data.friends || [], 'friend');
                    break;
                case 'groups_list':
                    updateTargetSelect(data.groups || [], 'group');
                    break;
                case 'flows_list':
                    updateFlowSelect(data.flows || []);
                    break;
            }
        }

        // ... (updateTargetSelect, updateFlowSelect remain same) ...
        let cachedFriends = [];
        let cachedGroups = [];
        function updateTargetSelect(items, type) {
            if (type === 'friend') cachedFriends = items;
            if (type === 'group') cachedGroups = items;
            renderTargetSelect();
        }

        function renderTargetSelect() {
            const select = document.getElementById('taskTargetSelect');
            const currentVal = select.value;
            select.innerHTML = '<option value="">-- Ch·ªçn ng∆∞·ªùi nh·∫≠n --</option>';

            if (cachedFriends.length > 0) {
                const optGroup = document.createElement('optgroup');
                optGroup.label = "üë§ B·∫°n b√®";
                cachedFriends.forEach(f => {
                    const opt = document.createElement('option');
                    opt.value = f.userId;
                    opt.textContent = f.displayName;
                    opt.dataset.name = f.displayName;
                    optGroup.appendChild(opt);
                });
                select.appendChild(optGroup);
            }
            if (cachedGroups.length > 0) {
                const optGroup = document.createElement('optgroup');
                optGroup.label = "üë™ Nh√≥m";
                cachedGroups.forEach(g => {
                    const opt = document.createElement('option');
                    opt.value = g.id;
                    opt.textContent = g.name;
                    opt.dataset.name = g.name;
                    optGroup.appendChild(opt);
                });
                select.appendChild(optGroup);
            }
            if (currentVal) select.value = currentVal;
        }

        let cachedFlows = [];
        function updateFlowSelect(flows) {
            cachedFlows = flows;
            const select = document.getElementById('taskFlowSelect');
            if (!select) return;
            const currentVal = select.value;

            select.innerHTML = '<option value="">-- Ch·ªçn k·ªãch b·∫£n (Flow) --</option>';
            flows.forEach(f => {
                const opt = document.createElement('option');
                opt.value = f.flowID;
                opt.textContent = `${f.triggerName ? `[${f.triggerName}] ` : ''}${f.flowName}`;
                select.appendChild(opt);
            });
            if (currentVal) select.value = currentVal;
        }

        // SINGLE TARGET CHANGE
        function onSingleTargetChange() {
            const select = document.getElementById('taskTargetSelect');
            if (select.value) {
                document.getElementById('taskTargetId').value = select.value;
            }
        }

        // LOAD MULTI SELECT
        async function loadMultiSelectTargets() {
            const container = document.getElementById('multiSelectContainer');
            if (window.cachedFriends) {
                renderMultiSelect(window.cachedFriends);
                return;
            }

            try {
                const response = await fetch('/api/friends'); // Assuming this endpoint exists or we use window.friends
                const friends = await response.json();
                window.cachedFriends = friends;
                renderMultiSelect(friends);
            } catch (e) {
                container.innerHTML = '<div style="color:red">L·ªói t·∫£i danh s√°ch b·∫°n b√®</div>';
            }
        }

        function renderMultiSelect(friends) {
            const container = document.getElementById('multiSelectContainer');
            container.innerHTML = friends.map(f => `
                <div class="friend-check-item" style="display:flex; align-items:center; padding:4px 0; border-bottom:1px solid #eee;">
                    <input type="checkbox" class="target-checkbox" value="${f.userId}" id="chk_${f.userId}" onchange="updateSelectedCount()">
                    <label for="chk_${f.userId}" style="flex:1; margin-left:8px; cursor:pointer; display:flex; align-items:center; gap:8px;">
                        <img src="${f.avatar || 'https://via.placeholder.com/30'}" style="width:24px; height:24px; border-radius:50%;">
                        <span>${escapeHtml(f.displayName)}</span>
                        <small style="color:#999; margin-left:auto;">${f.userId}</small>
                    </label>
                </div>
            `).join('');
            updateSelectedCount();
        }

        function selectAllTargets() {
            document.querySelectorAll('.target-checkbox').forEach(cb => cb.checked = true);
            updateSelectedCount();
        }

        function deselectAllTargets() {
            document.querySelectorAll('.target-checkbox').forEach(cb => cb.checked = false);
            updateSelectedCount();
        }

        function updateSelectedCount() {
            const count = document.querySelectorAll('.target-checkbox:checked').length;
            document.getElementById('selectedCount').textContent = `ƒê√£ ch·ªçn: ${count}`;

            // Update hidden input
            const ids = Array.from(document.querySelectorAll('.target-checkbox:checked')).map(cb => cb.value);
            document.getElementById('taskTargetId').value = ids.join(', ');
        }

        function loadTasks() {
            if (ws?.readyState === 1) ws.send(JSON.stringify({ type: 'get_scheduled_tasks' }));
        }

        function renderTasks() {
            const tbody = document.getElementById('tasksTable');
            if (tasks.length === 0) {
                tbody.innerHTML = `<tr><td colspan="8"><div class="empty-state"><div class="icon">üìÖ</div><h3>Ch∆∞a c√≥ l·ªãch g·ª≠i n√†o</h3></div></td></tr>`;
                return;
            }

            tbody.innerHTML = tasks.map((t, i) => {
                const time = new Date(t.executeTime).toLocaleString('vi-VN');
                const created = new Date(t.createdAt).toLocaleString('vi-VN');
                const statusClass = t.status.toLowerCase();

                return `
          <tr>
            <td>${i + 1}</td>
            <td>
              <strong>${escapeHtml(t.targetName || 'N/A')}</strong><br>
              <small style="opacity: 0.7">${t.targetId}</small>
            </td>
            <td><span class="type-badge ${t.type}">${t.type === 'flow' ? 'Flow' : (t.type === 'forward' ? 'Forward' : 'Text')}</span></td>
            <td>
               <div style="max-width: 250px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${escapeHtml(t.content)}">
                 ${escapeHtml(t.content)}
               </div>
            </td>
            <td>${time}</td>
            <td><span class="status-badge ${statusClass}">${t.status}</span></td>
            <td>${created}</td>
            <td>
              <div class="action-btns">
                <button class="action-btn edit" title="S·ª≠a" onclick="editTask(${t.id})" style="color:#2196F3;">‚úèÔ∏è</button>
                <button class="action-btn delete" title="X√≥a" onclick="deleteTask(${t.id})">üóëÔ∏è</button>
              </div>
            </td>
          </tr>
        `;
            }).join('');
        }

        // View Switching
        function switchView(view) {
            document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`.view-btn[onclick="switchView('${view}')"]`).classList.add('active');

            if (view === 'list') {
                document.getElementById('listView').style.display = 'block';
                document.getElementById('calendarView').style.display = 'none';
            } else {
                document.getElementById('listView').style.display = 'none';
                document.getElementById('calendarView').style.display = 'block';
                initCalendar();
            }
        }

        function initCalendar() {
            if (calendar) {
                calendar.render();
                return;
            }

            const calendarEl = document.getElementById('calendar');
            calendar = new FullCalendar.Calendar(calendarEl, {
                initialView: 'dayGridMonth',
                locale: 'vi',
                headerToolbar: {
                    left: 'prev,next today',
                    center: 'title',
                    right: 'dayGridMonth,timeGridWeek,timeGridDay'
                },
                events: getCalendarEvents(),
                dateClick: function (info) {
                    openCreateTask();
                    // Set clicked date as default
                    const date = new Date(info.date);
                    date.setMinutes(date.getMinutes() - date.getTimezoneOffset());
                    // Default to 8:00 AM if clicked on month view (which is midnight)
                    if (info.view.type === 'dayGridMonth') {
                        date.setHours(8, 0, 0, 0);
                    }
                    document.getElementById('taskTime').value = date.toISOString().slice(0, 16);
                },
                eventClick: function (info) {
                    const taskId = parseInt(info.event.id);
                    editTask(taskId);
                },
                eventContent: function (arg) {
                    return {
                        html: `<div style="font-size:11px; overflow:hidden; text-overflow:ellipsis;">
                                <b>${arg.timeText}</b> ${arg.event.title}
                               </div>`
                    };
                }
            });
            calendar.render();
        }

        function getCalendarEvents() {
            return tasks.map(t => ({
                id: t.id.toString(),
                title: `${t.type === 'flow' ? '‚ö°' : 'üí¨'} ${t.targetName}`,
                start: t.executeTime,
                backgroundColor: t.status === 'completed' ? '#28a745' : (t.status === 'failed' ? '#dc3545' : '#007bff'),
                borderColor: t.status === 'completed' ? '#28a745' : (t.status === 'failed' ? '#dc3545' : '#007bff')
            }));
        }

        function updateCalendarEvents() {
            if (calendar) {
                calendar.removeAllEvents();
                calendar.addEventSource(getCalendarEvents());
            }
        }

        // Create / Edit Logic
        function openCreateTask() {
            document.getElementById('taskModalTitle').textContent = 'T·∫°o l·ªãch g·ª≠i m·ªõi';
            document.getElementById('editingTaskId').value = '';

            document.getElementById('taskTargetSelect').value = '';
            document.getElementById('taskTargetId').value = '';
            document.getElementById('taskTargetId').style.display = 'none';
            document.getElementById('taskContent').value = '';
            document.getElementById('taskTime').value = '';
            document.getElementById('taskType').value = 'text';
            toggleTaskType();

            document.getElementById('taskModal').classList.add('active');
        }

        async function editTask(id) {
            const task = tasks.find(t => t.id === id);
            if (!task) return;

            document.getElementById('taskModalTitle').textContent = 'Ch·ªânh s·ª≠a l·ªãch g·ª≠i';
            document.getElementById('editingTaskId').value = task.id;

            if (task.type === 'forward') {
                // Pre-select checkboxes
                const ids = task.targetId.split(',').map(s => s.trim());
                // Need to wait for list load?
                await loadMultiSelectTargets();
                setTimeout(() => {
                    document.querySelectorAll('.target-checkbox').forEach(cb => {
                        cb.checked = ids.includes(cb.value);
                    });
                    updateSelectedCount();
                }, 500);
            } else {
                document.getElementById('taskTargetSelect').value = task.targetId;
                document.getElementById('taskTargetId').value = task.targetId;
            }

            document.getElementById('taskType').value = task.type;
            toggleTaskType();

            if (task.type === 'text') {
                document.getElementById('taskContent').value = task.content;
            } else {
                document.getElementById('taskFlowSelect').value = task.content;
            }

            // Format time for input
            const date = new Date(task.executeTime);
            date.setMinutes(date.getMinutes() - date.getTimezoneOffset());
            document.getElementById('taskTime').value = date.toISOString().slice(0, 16);

            document.getElementById('taskModal').classList.add('active');
        }

        function closeTaskModal() {
            document.getElementById('taskModal').classList.remove('active');
        }

        function toggleTaskType() {
            const type = document.getElementById('taskType').value;
            const contentLabel = document.querySelector('#groupContent label');
            const targetInput = document.getElementById('taskTargetId');

            const singleGroup = document.getElementById('singleTargetGroup');
            const multiArea = document.getElementById('targetSelectionArea');

            // Reset
            singleGroup.style.display = 'none';
            multiArea.style.display = 'none';
            document.getElementById('flowInputGroup').style.display = 'none';
            document.getElementById('groupContent').style.display = 'block';

            if (type === 'text') {
                singleGroup.style.display = 'block';
                contentLabel.innerHTML = 'N·ªôi dung tin nh·∫Øn <span class="required">*</span>';
                // Load options logic is already handled by loadFriends (which populates taskTargetSelect)
            } else if (type === 'flow') {
                document.getElementById('groupContent').style.display = 'none';
                document.getElementById('flowInputGroup').style.display = 'block';
                singleGroup.style.display = 'block';
            } else if (type === 'forward') {
                multiArea.style.display = 'block';
                contentLabel.innerHTML = 'N·ªôi dung c·∫ßn chuy·ªÉn ti·∫øp <span class="required">*</span>';
                loadMultiSelectTargets();
            }
        }

        function saveTask() {
            const editingId = document.getElementById('editingTaskId').value;

            const targetId = document.getElementById('taskTargetId').value.trim();
            const select = document.getElementById('taskTargetSelect');
            let targetName = select.options[select.selectedIndex]?.dataset.name || targetId;
            const type = document.getElementById('taskType').value;
            const timeStr = document.getElementById('taskTime').value;

            let content = '';
            if (type === 'flow') {
                content = document.getElementById('taskFlowSelect').value;
                if (!content) {
                    showToast('‚ùå Vui l√≤ng ch·ªçn k·ªãch b·∫£n workflow!', 'error');
                    return;
                }
            } else {
                // Text OR Forward
                content = document.getElementById('taskContent').value.trim();
            }

            // Fix targetName for forward
            if (type === 'forward') {
                const count = targetId.split(',').length;
                targetName = `${count} ng∆∞·ªùi nh·∫≠n`;
            }

            if (!targetId || !content || !timeStr) {
                showToast('‚ö†Ô∏è Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin!', 'error');
                return;
            }

            const executeTime = new Date(timeStr).getTime();
            // Allow editing past tasks to reschedule? Yes.
            if (executeTime < Date.now() && !editingId) {
                showToast('‚ö†Ô∏è Th·ªùi gian ph·∫£i l·ªõn h∆°n hi·ªán t·∫°i!', 'error');
                return;
            }

            if (editingId) {
                // Update
                ws.send(JSON.stringify({
                    type: 'update_scheduled_task',
                    id: parseInt(editingId),
                    updates: {
                        targetId,
                        targetName,
                        content,
                        type,
                        executeTime,
                        status: 'pending' // Reset status to pending on edit
                    }
                }));
            } else {
                // Create
                ws.send(JSON.stringify({
                    type: 'create_scheduled_task',
                    targetId,
                    targetName,
                    content,
                    taskType: type,
                    executeTime
                }));
            }
        }

        function deleteTask(id) {
            if (!confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a l·ªãch n√†y?')) return;
            ws.send(JSON.stringify({ type: 'delete_scheduled_task', id }));
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text || '';
            return div.innerHTML;
        }

        function showToast(msg, type = 'info') {
            const toast = document.createElement('div');
            toast.className = 'toast ' + type;
            toast.textContent = msg;
            toast.style.position = 'fixed';
            toast.style.bottom = '20px';
            toast.style.right = '20px';
            toast.style.padding = '12px 24px';
            toast.style.borderRadius = '8px';
            toast.style.color = 'white';
            toast.style.fontWeight = '500';
            toast.style.zIndex = '1000';
            toast.style.background = type === 'success' ? '#4CAF50' : (type === 'error' ? '#f44336' : '#2196F3');

            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }
    </script>
</body>

</html>